package main

import (
	"context"
	"errors"
	"net/http"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	"github.com/FyraLabs/subatomic/config"
	"github.com/FyraLabs/subatomic/gen/admin/v1/adminv1connect" // generated by protoc-gen-connect-go
	"github.com/FyraLabs/subatomic/property"
	"github.com/bufbuild/connect-go"

	"github.com/FyraLabs/subatomic/ent/repository"

	"github.com/ostreedev/ostree-go/pkg/otbuiltin"

	adminv1 "github.com/FyraLabs/subatomic/gen/admin/v1" // generated by protoc-gen-go
)

type AdminServer struct{}

func (s *AdminServer) CreateRepo(
	ctx context.Context,
	req *connect.Request[adminv1.CreateRepoRequest],
) (*connect.Response[adminv1.CreateRepoResponse], error) {
	exists, err := config.DatabaseClient.Repository.Query().Where(repository.NameEQ(req.Msg.Name)).Exist(ctx)

	if err != nil {
		return nil, err
	}

	if exists {
		return nil, connect.NewError(connect.CodeAlreadyExists, errors.New("repository already exists"))
	}

	repoType := property.RepositoryType(int(req.Msg.Type.Number()))

	repository_dir := path.Join(config.Environment.StorageDirectory, req.Msg.Name)

	switch repoType {
	case property.Dnf:
		if err := os.MkdirAll(repository_dir, os.ModePerm); err != nil {
			return nil, err
		}

		if _, err := exec.Command("createrepo_c", repository_dir).Output(); err != nil {
			return nil, err
		}
	case property.Ostree:
		options := otbuiltin.NewInitOptions()
		options.Mode = "bare"
		if _, err := otbuiltin.Init(repository_dir, options); err != nil {
			return nil, err
		}
	}

	_, err = config.DatabaseClient.Repository.Create().SetName(req.Msg.Name).SetType(repoType).Save(ctx)

	if err != nil {
		return nil, err
	}

	res := connect.NewResponse(&adminv1.CreateRepoResponse{
		Name: req.Msg.Name,
	})

	return res, nil
}

func (s *AdminServer) DeleteRepo(
	ctx context.Context,
	req *connect.Request[adminv1.DeleteRepoRequest],
) (*connect.Response[adminv1.DeleteRepoResponse], error) {
	exists, err := config.DatabaseClient.Repository.Query().Where(repository.NameEQ(req.Msg.Name)).Exist(ctx)

	if err != nil {
		return nil, err
	}

	if !exists {
		return nil, connect.NewError(connect.CodeAlreadyExists, errors.New("repository doesn't exist"))
	}

	if err := os.RemoveAll(path.Join(config.Environment.StorageDirectory, req.Msg.Name)); err != nil {
		return nil, err
	}

	if _, err := config.DatabaseClient.Repository.Delete().Where(repository.NameEQ(req.Msg.Name)).Exec(ctx); err != nil {
		return nil, err
	}

	res := connect.NewResponse(&adminv1.DeleteRepoResponse{})

	return res, nil
}

func (s *AdminServer) UploadArtifact(
	ctx context.Context,
	stream *connect.ClientStream[adminv1.UploadArtifactRequest],
) (*connect.Response[adminv1.UploadArtifactResponse], error) {
	var metadata *adminv1.UploadArtifactRequestMetadata
	var file *os.File

	repository_dir := path.Join(config.Environment.StorageDirectory, metadata.Name)

	for stream.Receive() {
		if metadata == nil {
			metadata = stream.Msg().GetMetadata()

			exists, err := config.DatabaseClient.Repository.Query().Where(repository.NameEQ(metadata.Name)).Exist(ctx)

			if err != nil {
				return nil, err
			}

			if !exists {
				return nil, connect.NewError(connect.CodeAlreadyExists, errors.New("repository doesn't exist"))
			}

			basename := path.Base(filepath.Clean(metadata.ArtifactName))

			file, err = os.Create(path.Join(repository_dir, strings.TrimSuffix(basename, filepath.Ext(basename))+".rpm"))

			if err != nil {
				return nil, err
			}

			continue
		}

		if _, err := file.Write(stream.Msg().GetChunkData()); err != nil {
			return nil, err
		}
	}

	if err := stream.Err(); err != nil {
		return nil, connect.NewError(connect.CodeUnknown, err)
	}

	if _, err := exec.Command("createrepo_c", "--update", repository_dir).Output(); err != nil {
		return nil, err
	}

	res := connect.NewResponse(&adminv1.UploadArtifactResponse{})

	return res, nil
}

func main() {
	if err := config.InitializeEnv(); err != nil {
		panic(err.Error())
	}

	if err := config.InitializeDatabase(); err != nil {
		panic(err.Error())
	}

	admin1 := &AdminServer{}
	mux := http.NewServeMux()
	path, handler := adminv1connect.NewAdminServiceHandler(admin1)
	mux.Handle(path, handler)
	println("Starting Connect server on :8080")
	http.ListenAndServe(
		":8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		h2c.NewHandler(mux, &http2.Server{}),
	)
}
